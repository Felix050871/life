# Workly - Guida al Deployment

## Indice
1. [Strategie di Deployment](#strategie-di-deployment)
2. [Deployment su Replit (Raccomandato)](#deployment-su-replit)
3. [Deployment su VPS/Server Dedicato](#deployment-su-vpsserver-dedicato)
4. [Deployment su Cloud Providers](#deployment-su-cloud-providers)
5. [Configurazione Produzione](#configurazione-produzione)
6. [Monitoraggio e Manutenzione](#monitoraggio-e-manutenzione)
7. [Backup e Recovery](#backup-e-recovery)
8. [Scaling e Performance](#scaling-e-performance)

## Strategie di Deployment

### 1. Replit (Raccomandato per MVP)
- ✅ **Setup automatico** - Zero configurazione
- ✅ **Database incluso** - PostgreSQL managed
- ✅ **SSL automatico** - HTTPS out-of-the-box
- ✅ **Scaling automatico** - Gestione carico automatica
- ✅ **Backup automatico** - Versioning integrato
- ❌ **Limitazioni risorse** - Per applicazioni grandi
- ❌ **Vendor lock-in** - Dipendenza piattaforma

### 2. VPS/Server Dedicato
- ✅ **Controllo completo** - Configurazione custom
- ✅ **Performance garantita** - Risorse dedicate
- ✅ **Costi prevedibili** - Pricing fisso
- ❌ **Manutenzione manuale** - Updates e sicurezza
- ❌ **Setup complesso** - Configurazione estesa

### 3. Cloud Providers (AWS/Azure/GCP)
- ✅ **Scalabilità infinita** - Auto-scaling
- ✅ **Alta disponibilità** - Multi-region
- ✅ **Servizi gestiti** - Database, storage, CDN
- ❌ **Complessità** - Learning curve
- ❌ **Costi variabili** - Pay-per-use

## Deployment su Replit

### 1. Preparazione Progetto

Il progetto è già ottimizzato per Replit con:

```bash
# File configurazione inclusi:
.replit              # Comando run e configurazione
replit.nix          # Ambiente Nix con dipendenze
pyproject.toml      # Gestione dipendenze Python
```

### 2. Setup Secrets

Nel pannello **Secrets** di Replit:

```
# Database (auto-fornito da Replit)
DATABASE_URL=<auto-generated-postgresql-url>

# Security
FLASK_SECRET_KEY=<generate-32-char-hex-key>

# Optional
FLASK_ENV=production
DEBUG=False
```

### 3. Deploy Steps

```bash
# 1. Import progetto su Replit
# 2. Configura secrets nel pannello
# 3. Avvia con il pulsante Run
# 4. L'app sarà disponibile su https://workly-xxx.replit.app
```

### 4. Custom Domain (Replit)

```bash
# Nel pannello Deployment:
# 1. Vai a "Deployments"
# 2. Clicca "Deploy" 
# 3. Configura custom domain se hai Replit Core
# 4. SSL automatico per tutti i domini
```

### 5. Monitoraggio Replit

```python
# Health check endpoint già incluso
@app.route('/health')
def health_check():
    return {'status': 'ok', 'timestamp': datetime.now().isoformat()}
```

## Deployment su VPS/Server Dedicato

### 1. Server Setup (Ubuntu 22.04)

```bash
# 1. Aggiornamento sistema
sudo apt update && sudo apt upgrade -y

# 2. Installazione stack completo
sudo apt install -y python3.11 python3.11-venv python3-pip \
                    postgresql postgresql-contrib \
                    nginx redis-server \
                    supervisor git curl

# 3. Configurazione firewall
sudo ufw allow ssh
sudo ufw allow 'Nginx Full'
sudo ufw enable
```

### 2. Database PostgreSQL

```bash
# Configurazione PostgreSQL
sudo -u postgres psql

CREATE DATABASE workly_prod;
CREATE USER workly_user WITH ENCRYPTED PASSWORD 'StrongPassword123!';
GRANT ALL PRIVILEGES ON DATABASE workly_prod TO workly_user;
ALTER USER workly_user CREATEDB;  -- Per testing
\q

# Configurazione connessioni remote (se necessario)
sudo nano /etc/postgresql/14/main/postgresql.conf
# listen_addresses = 'localhost'

sudo nano /etc/postgresql/14/main/pg_hba.conf
# host    workly_prod    workly_user    127.0.0.1/32    md5
```

### 3. Applicazione Setup

```bash
# Creazione utente applicazione
sudo useradd -m -s /bin/bash workly
sudo su - workly

# Deploy codice
git clone https://github.com/your-org/workly.git /home/workly/app
cd /home/workly/app

# Virtual environment
python3.11 -m venv venv
source venv/bin/activate
pip install --upgrade pip
pip install -r requirements.txt

# Configurazione environment
cat > .env << EOF
DATABASE_URL=postgresql://workly_user:StrongPassword123!@localhost/workly_prod
FLASK_SECRET_KEY=$(python -c "import secrets; print(secrets.token_hex(32))")
FLASK_ENV=production
DEBUG=False
PORT=5000
LOG_LEVEL=INFO
EOF

# Permissions
chmod 600 .env
```

### 4. Supervisor Configuration

```bash
# Configurazione Supervisor per gestione processo
sudo cat > /etc/supervisor/conf.d/workly.conf << EOF
[program:workly]
command=/home/workly/app/venv/bin/gunicorn --workers 3 --bind 127.0.0.1:5000 main:app
directory=/home/workly/app
user=workly
autostart=true
autorestart=true
redirect_stderr=true
stdout_logfile=/var/log/workly/app.log
environment=PATH="/home/workly/app/venv/bin"

[program:workly-worker]
command=/home/workly/app/venv/bin/python worker.py
directory=/home/workly/app
user=workly
autostart=true
autorestart=true
redirect_stderr=true
stdout_logfile=/var/log/workly/worker.log
EOF

# Creazione directory log
sudo mkdir -p /var/log/workly
sudo chown workly:workly /var/log/workly

# Avvio servizi
sudo supervisorctl reread
sudo supervisorctl update
sudo supervisorctl start workly:*
```

### 5. Nginx Configuration

```bash
# Configurazione Nginx
sudo cat > /etc/nginx/sites-available/workly << EOF
upstream workly_app {
    server 127.0.0.1:5000;
}

server {
    listen 80;
    server_name your-domain.com www.your-domain.com;
    
    # Redirect to HTTPS
    return 301 https://\$server_name\$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your-domain.com www.your-domain.com;

    # SSL Configuration (Let's Encrypt)
    ssl_certificate /etc/letsencrypt/live/your-domain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/your-domain.com/privkey.pem;
    
    # SSL Security
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;

    # Security Headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;

    # Rate Limiting
    limit_req_zone \$binary_remote_addr zone=login:10m rate=5r/m;
    
    location / {
        proxy_pass http://workly_app;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        
        # Timeouts
        proxy_connect_timeout       60s;
        proxy_send_timeout          60s;
        proxy_read_timeout          60s;
    }

    # Rate limit login endpoint
    location /login {
        limit_req zone=login burst=5 nodelay;
        proxy_pass http://workly_app;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }

    # Static files
    location /static/ {
        alias /home/workly/app/static/;
        expires 1y;
        add_header Cache-Control "public, immutable";
        
        # Compression
        gzip on;
        gzip_vary on;
        gzip_types text/css application/javascript image/svg+xml;
    }

    # Upload size
    client_max_body_size 10M;
}
EOF

# Attivazione sito
sudo ln -s /etc/nginx/sites-available/workly /etc/nginx/sites-enabled/
sudo nginx -t
sudo systemctl reload nginx
```

### 6. SSL Certificate

```bash
# Installazione Certbot
sudo apt install -y certbot python3-certbot-nginx

# Ottenimento certificato SSL
sudo certbot --nginx -d your-domain.com -d www.your-domain.com

# Auto-renewal setup
sudo cat > /etc/cron.d/certbot-renew << EOF
# Renew Let's Encrypt certificates
0 3 * * * root certbot renew --quiet --post-hook "systemctl reload nginx"
EOF
```

## Deployment su Cloud Providers

### 1. AWS Deployment

#### EC2 + RDS Setup
```bash
# 1. Launch EC2 instance (t3.medium recommended)
# 2. Create RDS PostgreSQL instance
# 3. Setup Security Groups
# 4. Follow VPS deployment steps
# 5. Configure ALB for load balancing

# Environment variables for AWS
DATABASE_URL=postgresql://user:pass@rds-endpoint:5432/workly
AWS_REGION=us-east-1
```

#### ECS Deployment
```dockerfile
# Dockerfile for containerized deployment
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 5000

CMD ["gunicorn", "--bind", "0.0.0.0:5000", "main:app"]
```

### 2. Azure Deployment

```bash
# Azure App Service
az webapp create --resource-group workly-rg \
                 --plan workly-plan \
                 --name workly-app \
                 --runtime "PYTHON|3.11"

# Database
az postgres server create --resource-group workly-rg \
                         --name workly-db \
                         --admin-user workly_admin
```

### 3. Google Cloud Platform

```yaml
# app.yaml for App Engine
runtime: python311

env_variables:
  DATABASE_URL: postgresql://user:pass@/workly?host=/cloudsql/project:region:instance
  FLASK_SECRET_KEY: your-secret-key

handlers:
- url: /static
  static_dir: static
- url: /.*
  script: auto
```

## Configurazione Produzione

### 1. Environment Variables

```bash
# Production .env template
DATABASE_URL=postgresql://user:pass@host:port/db
FLASK_SECRET_KEY=very-long-random-secret-key
FLASK_ENV=production
DEBUG=False
PORT=5000

# Logging
LOG_LEVEL=INFO
LOG_FILE=/var/log/workly/app.log

# Security
SECURE_SSL_REDIRECT=True
SESSION_COOKIE_SECURE=True
CSRF_COOKIE_SECURE=True

# Performance
SQLALCHEMY_ENGINE_OPTIONS='{"pool_size": 10, "pool_recycle": 3600}'
```

### 2. Gunicorn Production Config

```python
# gunicorn.conf.py
import multiprocessing

bind = "127.0.0.1:5000"
workers = multiprocessing.cpu_count() * 2 + 1
worker_class = "sync"
worker_connections = 1000
max_requests = 1000
max_requests_jitter = 100
timeout = 30
keepalive = 5

# Logging
accesslog = "/var/log/workly/access.log"
errorlog = "/var/log/workly/error.log"
loglevel = "info"

# Security
limit_request_line = 4096
limit_request_fields = 100
limit_request_field_size = 8190
```

### 3. Database Optimization

```sql
-- PostgreSQL production settings
-- postgresql.conf

shared_buffers = 256MB              # 25% of RAM
effective_cache_size = 1GB          # 75% of RAM
work_mem = 4MB                      # Per connection
maintenance_work_mem = 64MB

# Connections
max_connections = 100

# Logging
log_statement = 'mod'               # Log DDL/DML
log_min_duration_statement = 1000   # Log slow queries

# Performance
random_page_cost = 1.1              # For SSD
effective_io_concurrency = 200      # For SSD
```

## Monitoraggio e Manutenzione

### 1. Health Monitoring

```python
# health_check.py - Monitoring script
import requests
import time
import logging

def check_app_health():
    try:
        response = requests.get('https://your-domain.com/health', timeout=10)
        if response.status_code == 200:
            logging.info("App is healthy")
            return True
        else:
            logging.error(f"App unhealthy: {response.status_code}")
            return False
    except Exception as e:
        logging.error(f"Health check failed: {e}")
        return False

# Cron job: */5 * * * * /usr/bin/python /path/to/health_check.py
```

### 2. Log Monitoring

```bash
# Logrotate configuration
sudo cat > /etc/logrotate.d/workly << EOF
/var/log/workly/*.log {
    daily
    missingok
    rotate 52
    compress
    delaycompress
    notifempty
    create 644 workly workly
    postrotate
        supervisorctl restart workly
    endscript
}
EOF
```

### 3. Performance Monitoring

```python
# monitoring.py - Basic metrics collection
import psutil
import psycopg2
from datetime import datetime

def collect_metrics():
    metrics = {
        'timestamp': datetime.now(),
        'cpu_percent': psutil.cpu_percent(),
        'memory_percent': psutil.virtual_memory().percent,
        'disk_percent': psutil.disk_usage('/').percent,
    }
    
    # Database metrics
    try:
        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()
        cursor.execute("SELECT count(*) FROM pg_stat_activity WHERE state = 'active'")
        metrics['db_active_connections'] = cursor.fetchone()[0]
        conn.close()
    except Exception as e:
        metrics['db_error'] = str(e)
    
    return metrics
```

## Backup e Recovery

### 1. Database Backup

```bash
#!/bin/bash
# backup.sh - Automated database backup

BACKUP_DIR="/var/backups/workly"
DATE=$(date +%Y%m%d_%H%M%S)
DB_NAME="workly_prod"

mkdir -p $BACKUP_DIR

# Full backup
pg_dump -U workly_user -h localhost $DB_NAME | gzip > $BACKUP_DIR/workly_$DATE.sql.gz

# Cleanup old backups (keep 30 days)
find $BACKUP_DIR -name "workly_*.sql.gz" -mtime +30 -delete

echo "Backup completed: workly_$DATE.sql.gz"

# Cron: 0 2 * * * /home/workly/scripts/backup.sh
```

### 2. Application Backup

```bash
#!/bin/bash
# app_backup.sh - Application files backup

APP_DIR="/home/workly/app"
BACKUP_DIR="/var/backups/workly"
DATE=$(date +%Y%m%d_%H%M%S)

tar -czf $BACKUP_DIR/app_$DATE.tar.gz \
    --exclude=venv \
    --exclude=__pycache__ \
    --exclude=.git \
    $APP_DIR

echo "App backup completed: app_$DATE.tar.gz"
```

### 3. Recovery Procedures

```bash
# Database Recovery
gunzip -c /var/backups/workly/workly_20240130_020000.sql.gz | \
    psql -U workly_user -h localhost -d workly_prod

# Application Recovery
cd /home/workly
tar -xzf /var/backups/workly/app_20240130_020000.tar.gz
sudo supervisorctl restart workly:*
```

## Scaling e Performance

### 1. Horizontal Scaling

```bash
# Load Balancer Configuration (HAProxy)
backend workly_servers
    balance roundrobin
    server workly1 192.168.1.10:5000 check
    server workly2 192.168.1.11:5000 check
    server workly3 192.168.1.12:5000 check
```

### 2. Database Read Replicas

```python
# database.py - Read/Write splitting
class DatabaseRouter:
    def __init__(self):
        self.write_db = "postgresql://user:pass@master:5432/workly"
        self.read_db = "postgresql://user:pass@replica:5432/workly"
    
    def get_connection(self, write=False):
        return self.write_db if write else self.read_db
```

### 3. Caching Strategy

```python
# caching.py - Redis caching
import redis
import json
from functools import wraps

redis_client = redis.Redis(host='localhost', port=6379, db=0)

def cache_result(expiration=300):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            cache_key = f"{func.__name__}:{hash(str(args) + str(kwargs))}"
            
            # Try cache first
            cached = redis_client.get(cache_key)
            if cached:
                return json.loads(cached)
            
            # Execute and cache
            result = func(*args, **kwargs)
            redis_client.setex(cache_key, expiration, json.dumps(result))
            return result
        
        return wrapper
    return decorator
```

### 4. CDN Integration

```html
<!-- Static files via CDN -->
<link href="https://cdn.yourdomain.com/static/css/style.css" rel="stylesheet">
<script src="https://cdn.yourdomain.com/static/js/main.js"></script>
```

## Security Checklist

### 1. Application Security
- ✅ CSRF protection enabled
- ✅ SQL injection protection (SQLAlchemy ORM)
- ✅ XSS protection (Jinja2 autoescaping)
- ✅ Secure session management
- ✅ Input validation and sanitization

### 2. Infrastructure Security
- ✅ SSL/TLS encryption (HTTPS)
- ✅ Firewall configuration
- ✅ Database access restrictions
- ✅ Regular security updates
- ✅ Log monitoring and alerting

### 3. Data Protection
- ✅ Password hashing (Werkzeug)
- ✅ Sensitive data encryption at rest
- ✅ Regular backups
- ✅ Access logging and audit trails
- ✅ GDPR compliance considerations

Questa guida fornisce una strategia completa per il deployment di Workly in diversi ambienti, dalla prototipazione su Replit fino alla produzione enterprise su cloud provider.